#include "/home/terra/TerraNG/terra/TerraNet.defs"
// 5 types of messages:
    // NEIGHBOURS package with nodeId to be used in INITIALIZATION ROUTINE
    
    // EVENT AGENT - carries information that an event was detected

    // INTEREST AGENT - carries information that a node has interest in event

    // EVENT INFORMATION - carries the actual info on the event

    // REQUEST - requests an event information

// 3 "tables"
    // NEIGHBOURS - nodeId of each neighbour (received in INITIALIZATION ROUTINE)
    // EVENT - nodeId of neighbours that broadcasted event source notification.
    // INTEREST - nodeId of neighbours that broadcasted interest in an event..
// EVENT and INTEREST might not need to be tables since the number of events is small
// and thus can be separate variables (EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX where
// XX can be LT for low temp and HT for high temp). In case optimzation is done (shortest
// path) then theres also need for a third and fourth type of variable "N_JUMPS_ORIGIN_XX"
// and N_JUMPS_INTEREST_XX which keeps track of the number of jumps till origin associated
// with the neighbour in EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX.

#define N_NODES 8
#define MAX_HOPS 4

var ushort nodeId = getNodeId();

// DIFFERENT MESSAGE TYPES
#define NEIGHBOUR_INFO       1

#define MIN 0
#define MAX 1

// DEBUG INFO
#define SOURCE 1
#define INFO 2
#define INTEREST 3
#define REQUEST 4

//Types are build as 2^(TYPE) + (MIN/MAX)
// So SOURCE_MIN = 2 SOURCE_MAX = 3 INFO_MIN = 4 INFO_MAX = 5 etc

#define TYPE(X,Y) ((1 << X) + Y)
#define GET_TYPE(X) (X / 2)
#define GET_MIN_MAX(X) (X % 2)


// Is this enough to support the messages passed in?
pktype eventMsg from radioMsg with
	var ulong  hops;
    var ubyte  origin;
	var ulong temp;
end

//neighbours

var ubyte[8] neighbours;
var ubyte nNeighbours = 0;

//Tables:

regtype eventMetaTable with 
    var ubyte[2] neighbour;
    var ulong[2] hops;
end

var ubyte[2] sourceFlag;

regtype interestInfo with // type of queue elements
    var ubyte source;
    var ubyte type;
end

var eventMetaTable table; // armazenam sources


// Event INFO
var ubyte hasMaxTemp = 0;
var ubyte hasMinTemp = 0;
var long maxTemp;
var long minTemp;


// Identify all the neighbours:
    // BROADCAST nodeId.
    // Receive nodeIds for X ms
        // Foreach nodeId received, add to table of neighbours


// INITIALIZATION ROUTINE, for 1 sec will keep broadcasting its nodeId
// to all the neighbours and will receive from neighbours their nodeId
// and add them to a table if not there already.
par/or do
    await 5s;
with
	loop do
		var eventMsg message = await RECEIVE;
		if message.type == NEIGHBOUR_INFO then
		    var ubyte neighbour = message.source;
		    var ubyte flag = 0;

			loop i,nNeighbours do
			    if neighbours[i] == neighbour then
			        flag = 1;
			        break;
			    end
			end

		    if flag == 0 then
		        neighbours[nNeighbours]=neighbour;
		        inc nNeighbours;
		    end

		end
	end
with
    loop do
        // EVERY 100ms, sends broadcast to all neighbours
        await 100ms;
        var eventMsg neighbourmsg;
        neighbourmsg.type = NEIGHBOUR_INFO;
        neighbourmsg.source = nodeId;
        neighbourmsg.target = BROADCAST;
        emit SEND(neighbourmsg);
        await SEND_DONE;
    end
end

var eventMsg sendMessage;
sendMessage.source = nodeId;

par/and do

    if nodeId == 22 then
       loop do

			await 50s;        	
        	sendMessage.type = TYPE(SOURCE,MIN);
        	sendMessage.hops = 1; 
        	var ubyte index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];

        	emit SEND(sendMessage);
        	emit LEDS(TYPE(SOURCE,MIN));
		end
    end
	if nodeId == 44 then
		loop do
			await 40s;
        	sendMessage.type = TYPE(INTEREST,MIN);
        	sendMessage.hops = 1; 
        	var ubyte index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];

        	emit SEND(sendMessage);
        	emit LEDS(TYPE(INTEREST,MIN));
		end
	end
    
with
    loop do
        var eventMsg sendMessage;
        var eventMsg message = await RECEIVE;
        var ubyte type_raw = message.type;
        var ubyte type = GET_TYPE(type_raw);
        var ubyte min_max = GET_MIN_MAX(type_raw);
        var ubyte send = TRUE;
        sendMessage.type = type_raw;
        var ubyte index_n = (random()%nNeighbours);
        sendMessage.target = neighbours[index_n];
        sendMessage.hops = table_source.hops[index]+1;

        var interestInfo interest;
        interest.type = type_raw;
        interest.source = message.source;

        if type == SOURCE then
            emit LEDS(type_raw);
            
            if sourceFlag[min_max] == 0 then
                sourceFlag[min_max] = 1;
                table_source.hops[min_max] = message.hops;
                table_source.neighbour[min_max] = message.source;
            else
                if table_source.hops[min_max] > message.hops then
                    table_source.hops[min_max] = message.hops;
                    table_source.neighbour[min_max] = message.source;
                end
            end

            if message.hops >= MAX_HOPS then
                send = FALSE;
            end
        else/if type == INTEREST then
            
            

			end

        end

        if send == TRUE then
            emit SEND(sendMessage);
        end

    end
end

