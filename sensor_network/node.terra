#include "/home/terra/TerraNG/terra/TerraNet.defs"
// 5 types of messages:
    // NEIGHBOURS package with nodeId to be used in INITIALIZATION ROUTINE
    
    // EVENT AGENT - carries information that an event was detected

    // INTEREST AGENT - carries information that a node has interest in event

    // EVENT INFORMATION - carries the actual info on the event

    // REQUEST - requests an event information

// 3 "tables"
    // NEIGHBOURS - nodeId of each neighbour (received in INITIALIZATION ROUTINE)
    // EVENT - nodeId of neighbours that broadcasted event source notification.
    // INTEREST - nodeId of neighbours that broadcasted interest in an event..
// EVENT and INTEREST might not need to be tables since the number of events is small
// and thus can be separate variables (EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX where
// XX can be LT for low temp and HT for high temp). In case optimzation is done (shortest
// path) then theres also need for a third and fourth type of variable "N_JUMPS_ORIGIN_XX"
// and N_JUMPS_INTEREST_XX which keeps track of the number of jumps till origin associated
// with the neighbour in EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX.

#define N_NODES 8
#define MAX_HOPS 4

var ushort nodeId = getNodeId();

// DIFFERENT MESSAGE TYPES
#define NEIGHBOUR_INFO       1

#define MIN 0
#define MAX 1

// DEBUG INFO
#define SOURCE 1
#define INTEREST 2
#define INFO 3
#define REQUEST 4

//Types are build as 2^(TYPE) + (MIN/MAX)
// So SOURCE_MIN = 2 SOURCE_MAX = 3 INFO_MIN = 4 INFO_MAX = 5 etc

#define TYPE(X,Y) ((X * 2) + Y)
#define GET_TYPE(X) (X / 2)
#define GET_MIN_MAX(X) (X % 2)


// Is this enough to support the messages passed in?
pktype eventMsg from radioMsg with
	var ulong  hops;
    var ubyte  origin;
	var ulong temp;
end

//neighbours

var ubyte[8] neighbours;
var ubyte nNeighbours = 0;

//Tables:

regtype eventMetaTable with 
    var ubyte[2] neighbour;
    var ulong[2] hops;
end

var ubyte[2] sourceFlag; // has source set
sourceFlag[MIN] = FALSE;
sourceFlag[MAX] = FALSE;
var ubyte[2] interestFlag; // has interest set
interestFlag[MIN] = FALSE;
interestFlag[MAX] = FALSE;
var ubyte[2] waitingForInfo;
waitingForInfo[MIN] = FALSE;
waitingForInfo[MAX] = FALSE;

pktype interestInfo from radioMsg with // type of queuements
end

var eventMetaTable table_source; // armazenam sources


// Event INFO
var ubyte[2] hasTemp;
var long[2] temp;


// Identify all the neighbours:
    // BROADCAST nodeId.
    // Receive nodeIds for X ms
        // Foreach nodeId received, add to table of neighbours


// INITIALIZATION ROUTINE, for 1 sec will keep broadcasting its nodeId
// to all the neighbours and will receive from neighbours their nodeId
// and add them to a table if not there already.
par/or do
    await 5s;
with
	loop do
		var eventMsg message = await RECEIVE;
		if message.type == NEIGHBOUR_INFO then
		    var ubyte neighbour = message.source;
		    var ubyte flag = 0;

			loop i,nNeighbours do
			    if neighbours[i] == neighbour then
			        flag = 1;
			        break;
			    end
			end

		    if flag == 0 then
		        neighbours[nNeighbours]=neighbour;
		        inc nNeighbours;
		    end

		end
	end
with
    loop do
        // EVERY 100ms, sends broadcast to all neighbours
        await 100ms;
        var eventMsg neighbourmsg;
        neighbourmsg.type = NEIGHBOUR_INFO;
        neighbourmsg.source = nodeId;
        neighbourmsg.target = BROADCAST;
        emit SEND(neighbourmsg);
        await SEND_DONE;
    end
end

var eventMsg sendMessage;
sendMessage.source = nodeId;

emit LEDS(OFF);

par/and do

    if nodeId == 22 then
       loop do			        	
        	sendMessage.type = TYPE(SOURCE,MIN);
        	sendMessage.hops = 1; 
        	var ubyte index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];
			hasTemp[MIN] = TRUE;
			table_source.hops[MIN] = 0;
			table_source.neighbour[MIN] = nodeId;
			sourceFlag[MIN] = TRUE;
        	emit SEND(sendMessage);
        	//emit LEDS(TYPE(SOURCE,MIN));
			await 50s;
		end
    end
	if nodeId == 33 then
		loop do

        	sendMessage.type = TYPE(INTEREST,MIN);
        	sendMessage.hops = 1; 
        	var ubyte index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];
        	emit SEND(sendMessage);
        	//emit LEDS(TYPE(INTEREST,MIN));
			await 40s;
		end
	end
    
with
    loop do
        var eventMsg message = await RECEIVE;
        var ubyte type_raw = message.type;
        var ubyte type = GET_TYPE(type_raw);
        var ubyte min_max = GET_MIN_MAX(type_raw);
        var ubyte send = TRUE;
        sendMessage.type = type_raw;
        var ubyte index_n = (random()%nNeighbours);
        sendMessage.target = neighbours[index_n];
        sendMessage.hops = table_source.hops[min_max]+1;

        var interestInfo interest;
        interest.type = type_raw;
        interest.source = message.source;

        //emit LEDS(type_raw);
        if type == SOURCE then
            if sourceFlag[min_max] == 0 then
                sourceFlag[min_max] = 1;
                table_source.hops[min_max] = message.hops;
                table_source.neighbour[min_max] = message.source;
            else
                if table_source.hops[min_max] > message.hops then
                    table_source.hops[min_max] = message.hops;
                    table_source.neighbour[min_max] = message.source;
                end
            end

            if message.hops >= MAX_HOPS then
                send = FALSE;
            end
        else/if type == INTEREST then
			qPut(interest);

			interestFlag[min_max] = TRUE;

		else/if type == REQUEST then
			//emit LED0(ON);
			// colocar na queue
			qPut(interest);
			// repassar
			if waitingForInfo[min_max] == FALSE then
				waitingForInfo[min_max] = TRUE;
			else
				send = FALSE;
			end
			if hasTemp[min_max] then
				// tem informacao, deve gerar informacao
				emit LEDS(7);
				await FOREVER;
			end
			emit LEDS(OFF);
			emit LED0(ON);
        end        

		if send == TRUE then
            emit SEND(sendMessage);
        end

		if waitingForInfo[min_max] == FALSE and sourceFlag[min_max] == TRUE and interestFlag[min_max] == TRUE then
			// dispara request
			//emit LEDS(7);
			sendMessage.type = TYPE(REQUEST,min_max);
			sendMessage.target = table_source.neighbour[min_max];
			sendMessage.hops = 1;
			waitingForInfo[min_max] = TRUE;
			emit SEND(sendMessage);
		end

		//await 500ms;

    end
end

