#include "/home/terra/TerraNG/terra/TerraNet.defs"
// 5 types of messages:
    // NEIGHBOURS package with nodeId to be used in INITIALIZATION ROUTINE
    
    // EVENT AGENT - carries information that an event was detected

    // INTEREST AGENT - carries information that a node has interest in event

    // EVENT INFORMATION - carries the actual info on the event

    // REQUEST - requests an event information

// 3 "tables"
    // NEIGHBOURS - nodeId of each neighbour (received in INITIALIZATION ROUTINE)
    // EVENT - nodeId of neighbours that broadcasted event source notification.
    // INTEREST - nodeId of neighbours that broadcasted interest in an event..
// EVENT and INTEREST might not need to be tables since the number of events is small
// and thus can be separate variables (EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX where
// XX can be LT for low temp and HT for high temp). In case optimzation is done (shortest
// path) then theres also need for a third and fourth type of variable "N_JUMPS_ORIGIN_XX"
// and N_JUMPS_INTEREST_XX which keeps track of the number of jumps till origin associated
// with the neighbour in EVENT_ORIGIN_XX and INTEREST_ORIGIN_XX.

#define N_NODES 8
#define MAX_HOPS 4

var ushort nodeId = getNodeId();

// DIFFERENT MESSAGE TYPES
#define NEIGHBOUR_INFO       1

#define MIN 0
#define MAX 1

// DEBUG INFO
#define SOURCE 1
#define INTEREST 2
#define INFO 3
#define REQUEST 4

//Types are build as 2^(TYPE) + (MIN/MAX)
// So SOURCE_MIN = 2 SOURCE_MAX = 3 INFO_MIN = 4 INFO_MAX = 5 etc

#define TYPE(X,Y) ((X * 2) + Y)
#define GET_TYPE(X) (X / 2)
#define GET_MIN_MAX(X) (X % 2)


// Is this enough to support the messages passed in?
pktype eventMsg from radioMsg with
	var ulong  hops;
    var ubyte  origin;
	var ushort temp;
end

//neighbours

var ushort[8] neighbours;
var ubyte nNeighbours = 0;

//Tables:

regtype eventMetaTable with 
    var ushort[2] neighbour;
    var ulong[2] hops;
end

var ubyte[2] sourceFlag; // has source set
sourceFlag[MIN] = FALSE;
sourceFlag[MAX] = FALSE;
var ubyte[2] interestFlag; // has interest set
interestFlag[MIN] = FALSE;
interestFlag[MAX] = FALSE;
var ubyte[2] waitingForInfo;
waitingForInfo[MIN] = FALSE;
waitingForInfo[MAX] = FALSE;

var ubyte[2] selfInterestFlag; // true if this node origined an interest;  
selfInterestFlag[MIN] = FALSE;
selfInterestFlag[MAX] = FALSE;

pktype interestInfo from radioMsg with // type of queuements
end

var eventMetaTable table_source; // armazenam sources


// Event INFO
var ubyte[2] hasTemp;
hasTemp[MIN] = FALSE;
hasTemp[MAX] = FALSE;
var ushort[2] temp;


// Identify all the neighbours:
    // BROADCAST nodeId.
    // Receive nodeIds for X ms
        // Foreach nodeId received, add to table of neighbours


// INITIALIZATION ROUTINE, for 1 sec will keep broadcasting its nodeId
// to all the neighbours and will receive from neighbours their nodeId
// and add them to a table if not there already.
par/or do
    await 5s;
with
	loop do
		var eventMsg message = await RECEIVE;
		if message.type == NEIGHBOUR_INFO then
		    var ushort neighbour = message.source;
		    var ubyte flag = 0;

			loop i,nNeighbours do
			    if neighbours[i] == neighbour then
			        flag = 1;
			        break;
			    end
			end

		    if flag == 0 then
		        neighbours[nNeighbours]=neighbour;
		        inc nNeighbours;
		    end

		end
	end
with
    loop do
        // EVERY 100ms, sends broadcast to all neighbours
        await 100ms;
        var eventMsg neighbourmsg;
        neighbourmsg.type = NEIGHBOUR_INFO;
        neighbourmsg.source = nodeId;
        neighbourmsg.target = BROADCAST;
        emit SEND(neighbourmsg);
        await SEND_DONE;
    end
end

var eventMsg sendMessage;
sendMessage.source = nodeId;

emit LEDS(OFF);

par/and do

    loop do
        var eventMsg message = await RECEIVE;
        var ubyte type_raw = message.type;
        var ubyte type = GET_TYPE(type_raw);
        var ubyte min_max = GET_MIN_MAX(type_raw);
        var ubyte send = TRUE;
        sendMessage.type = type_raw;
        var ushort index_n = (random()%nNeighbours);
        sendMessage.target = neighbours[index_n];
        sendMessage.hops = table_source.hops[min_max]+1;

        var interestInfo interest;
        interest.type = min_max;
        interest.source = message.source;

        // emit LEDS(type_raw);
        if type == SOURCE then
            if sourceFlag[min_max] == 0 then
                sourceFlag[min_max] = 1;
                table_source.hops[min_max] = message.hops;
                table_source.neighbour[min_max] = message.source;
            else
                if table_source.hops[min_max] > message.hops then
                    table_source.hops[min_max] = message.hops;
                    table_source.neighbour[min_max] = message.source;
                end
            end            
        else/if type == INTEREST then
			qPut(interest);

			interestFlag[min_max] = TRUE;

		else/if type == REQUEST then
			//emit LED0(ON);
			// colocar na queue
			qPut(interest);
			// repassar
			if waitingForInfo[min_max] == FALSE then
				waitingForInfo[min_max] = TRUE;
			else
				send = FALSE;
			end
			if hasTemp[min_max] then
				// tem informacao, deve gerar informacao
				
				emit LEDS(OFF);
				emit LEDS(6);

				sendMessage.type = TYPE(INFO,min_max);
				sendMessage.hops = 1;
				sendMessage.temp = temp[min_max];
				send = TRUE;
				//await FOREVER;
			end
		else/if type == INFO then
			emit LEDS(OFF);			
			emit LEDS(3);
			//await FOREVER;

			sendMessage.temp = message.temp;
			//if nodeId == 33 and message.temp == 10 then
			//	emit LEDS(7);
			//	await FOREVER;
			//end

			if selfInterestFlag[min_max] then // informação chegou no nó de origem da busca
				emit LEDS(7);
				await FOREVER;
			end
			loop i,qSize() do
				emit LEDS(1);
				qGet(interest);

				if interest.type == min_max then
				// Se o interesse e a info forem do mesmo tipo, repassa a info
					sendMessage.target = interest.source;

					emit SEND(sendMessage);
				else
				// se forem de tipos diferentes, coloca o interesse na fila novamente
					qPut(interest);
				end
				interestFlag[min_max] = FALSE;
				waitingForInfo[min_max] = FALSE;
			end
		else
			send = FALSE;
        end        
		if message.hops >= MAX_HOPS then
            send = FALSE;
        end
		if send == TRUE then
			emit LEDS(5);
            emit SEND(sendMessage);
        end

		if waitingForInfo[min_max] == FALSE and sourceFlag[min_max] == TRUE and interestFlag[min_max] == TRUE then
			// dispara request
			emit LEDS(7);
			sendMessage.type = TYPE(REQUEST,min_max);
			sendMessage.target = table_source.neighbour[min_max];
			sendMessage.hops = 1;
			waitingForInfo[min_max] = TRUE;
			emit SEND(sendMessage);
		end

		//await 500ms;

    end

with

	loop do
		await 5s;
		emit REQ_TEMP;

		var ushort value = await TEMP;
		var ubyte trig = FALSE;
		var ubyte minMaxType;

		if value > 550 then
			minMaxType = MAX;
			trig = TRUE;
		else/if value < 450 then
			minMaxType = MIN;
			trig = TRUE;
		end

		if trig == TRUE then
			emit LED0(ON);
			sendMessage.type = TYPE(SOURCE,minMaxType);
        	sendMessage.hops = 1; 
        	var ushort index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];
			hasTemp[minMaxType] = TRUE;
			temp[minMaxType] = value;
			table_source.hops[minMaxType] = 0;
			table_source.neighbour[minMaxType] = nodeId;
			sourceFlag[minMaxType] = TRUE;
        	emit SEND(sendMessage);
			await SEND_DONE;
		end

		emit REQ_PHOTO;

		value = await PHOTO;
		trig = FALSE;

		if value > 450 then		
			minMaxType = MAX;
			trig = TRUE;
		else/if value < 350 then
			minMaxType = MIN;
			trig = TRUE;
		end

		if trig == TRUE then
			emit LED1(ON);
			selfInterestFlag[minMaxType] = TRUE;
			sendMessage.type = TYPE(INTEREST,minMaxType);
        	sendMessage.hops = 1; 
        	var ushort index = (random() % nNeighbours);
        	sendMessage.target = neighbours[index];
        	emit SEND(sendMessage);
			await SEND_DONE;
		end

	end
end

